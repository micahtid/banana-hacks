"""
BananaTrade Firebase Cloud Functions
Python implementation for game logic, trading, and bot management
"""

from firebase_functions import https_fn, scheduler_fn
from firebase_admin import initialize_app, firestore
import google.cloud.firestore
from datetime import datetime, timedelta
import math
import random
from typing import Dict, List, Optional

# Initialize Firebase
initialize_app()
db = firestore.client()

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

def calculate_decay(coins: float, last_tick: int, current_tick: int, decay_rate: float = 0.001) -> float:
    """Calculate banana decay for inactive wallets"""
    ticks_elapsed = current_tick - last_tick
    if ticks_elapsed <= 0:
        return coins
    return coins * math.exp(-decay_rate * ticks_elapsed)


def calculate_volatility(price_history: List[float], window: int = 20) -> float:
    """Calculate rolling volatility from recent returns"""
    if len(price_history) < 2:
        return 0.01
    
    recent_prices = price_history[-window:]
    returns = []
    for i in range(1, len(recent_prices)):
        if recent_prices[i-1] != 0:
            returns.append((recent_prices[i] - recent_prices[i-1]) / recent_prices[i-1])
    
    if not returns:
        return 0.01
    
    mean_return = sum(returns) / len(returns)
    variance = sum((r - mean_return) ** 2 for r in returns) / len(returns)
    return math.sqrt(variance)


def update_market_price(current_price: float, volatility: float, drift: float = -0.001) -> float:
    """Generate next price with drift and random walk"""
    noise = random.gauss(0, volatility)
    new_price = current_price * (1 + drift + noise)
    return max(0.01, new_price)  # Prevent price from going negative


def trigger_random_event(current_tick: int, event_probability: float = 0.05) -> Optional[Dict]:
    """Randomly trigger market events"""
    if random.random() > event_probability:
        return None
    
    events = [
        {"type": "crash", "name": "Banana Ship Sinks!", "impact": -0.15},
        {"type": "surge", "name": "Bumper Harvest!", "impact": 0.20},
        {"type": "hype", "name": "Celebrity Endorsement!", "impact": 0.10},
        {"type": "rot", "name": "Fungus Outbreak!", "impact": -0.08},
        {"type": "demand", "name": "Export Boom!", "impact": 0.12}
    ]
    
    event = random.choice(events)
    return {
        "type": event["type"],
        "name": event["name"],
        "impact": event["impact"],
        "tick": current_tick
    }


# ============================================================================
# GAME MANAGEMENT
# ============================================================================

@https_fn.on_call()
def create_game(req: https_fn.CallableRequest) -> Dict:
    """
    Create a new game room
    
    Request data:
        host_id: str
        settings: {
            duration: int (seconds),
            max_players: int,
            starting_capital: float,
            allow_bots: bool
        }
    """
    try:
        data = req.data
        host_id = data.get("host_id")
        settings = data.get("settings", {})
        
        game_ref = db.collection("games").document()
        game_id = game_ref.id
        
        game_data = {
            "game_id": game_id,
            "host_id": host_id,
            "is_started": False,
            "is_finished": False,
            "created_at": firestore.SERVER_TIMESTAMP,
            "start_time": None,
            "start_tick": None,
            "current_tick": 0,
            "coin_value": 1.0,
            "price_history": [1.0],
            "volatility": 0.02,
            "settings": {
                "duration": settings.get("duration", 3600),  # Default 1 hour
                "max_players": settings.get("max_players", 10),
                "starting_capital": settings.get("starting_capital", 1000.0),
                "starting_coins": settings.get("starting_coins", 100.0),
                "allow_bots": settings.get("allow_bots", True)
            },
            "events": [],
            "player_count": 0
        }
        
        game_ref.set(game_data)
        
        return {"success": True, "game_id": game_id}
    
    except Exception as e:
        return {"success": False, "error": str(e)}


@https_fn.on_call()
def join_game(req: https_fn.CallableRequest) -> Dict:
    """
    Join an existing game
    
    Request data:
        user_id: str
        user_name: str
        game_id: str
    """
    try:
        data = req.data
        user_id = data.get("user_id")
        user_name = data.get("user_name")
        game_id = data.get("game_id")
        
        game_ref = db.collection("games").document(game_id)
        game = game_ref.get()
        
        if not game.exists:
            return {"success": False, "error": "Game not found"}
        
        game_data = game.to_dict()
        
        if game_data.get("is_started"):
            return {"success": False, "error": "Game already started"}
        
        if game_data.get("player_count", 0) >= game_data["settings"]["max_players"]:
            return {"success": False, "error": "Game is full"}
        
        # Create user document in subcollection
        user_ref = game_ref.collection("users").document(user_id)
        
        if user_ref.get().exists:
            return {"success": False, "error": "Already in this game"}
        
        user_data = {
            "user_id": user_id,
            "user_name": user_name,
            "coins": game_data["settings"]["starting_coins"],
            "usd": game_data["settings"]["starting_capital"],
            "last_interaction_tick": 0,
            "bots": [],
            "joined_at": firestore.SERVER_TIMESTAMP
        }
        
        user_ref.set(user_data)
        
        # Increment player count
        game_ref.update({"player_count": firestore.Increment(1)})
        
        return {"success": True, "message": "Joined game successfully"}
    
    except Exception as e:
        return {"success": False, "error": str(e)}


@https_fn.on_call()
def start_game(req: https_fn.CallableRequest) -> Dict:
    """
    Start the game (host only)
    
    Request data:
        game_id: str
        host_id: str
    """
    try:
        data = req.data
        game_id = data.get("game_id")
        host_id = data.get("host_id")
        
        game_ref = db.collection("games").document(game_id)
        game = game_ref.get()
        
        if not game.exists:
            return {"success": False, "error": "Game not found"}
        
        game_data = game.to_dict()
        
        if game_data["host_id"] != host_id:
            return {"success": False, "error": "Only host can start game"}
        
        if game_data.get("is_started"):
            return {"success": False, "error": "Game already started"}
        
        # Initialize game state
        start_time = datetime.utcnow()
        game_ref.update({
            "is_started": True,
            "start_time": start_time,
            "start_tick": 0,
            "current_tick": 0
        })
        
        return {"success": True, "message": "Game started!", "start_time": start_time.isoformat()}
    
    except Exception as e:
        return {"success": False, "error": str(e)}


# ============================================================================
# TRADING FUNCTIONS
# ============================================================================

@https_fn.on_call()
def buy(req: https_fn.CallableRequest) -> Dict:
    """
    Buy BananaCoin
    
    Request data:
        user_id: str
        game_id: str
        num_bc: float
    """
    try:
        data = req.data
        user_id = data.get("user_id")
        game_id = data.get("game_id")
        num_bc = float(data.get("num_bc"))
        
        if num_bc <= 0:
            return {"success": False, "error": "Amount must be positive"}
        
        game_ref = db.collection("games").document(game_id)
        user_ref = game_ref.collection("users").document(user_id)
        
        # Use transaction for consistency
        @firestore.transactional
        def execute_buy(transaction):
            game_snap = game_ref.get(transaction=transaction)
            user_snap = user_ref.get(transaction=transaction)
            
            if not game_snap.exists or not user_snap.exists:
                raise ValueError("Game or user not found")
            
            game_data = game_snap.to_dict()
            user_data = user_snap.to_dict()
            
            if not game_data.get("is_started"):
                raise ValueError("Game not started")
            
            current_price = game_data["coin_value"]
            current_tick = game_data["current_tick"]
            cost = num_bc * current_price
            
            if user_data["usd"] < cost:
                raise ValueError("Insufficient USD")
            
            # Update user wallet
            transaction.update(user_ref, {
                "usd": user_data["usd"] - cost,
                "coins": user_data["coins"] + num_bc,
                "last_interaction_tick": current_tick
            })
            
            return {
                "new_usd": user_data["usd"] - cost,
                "new_coins": user_data["coins"] + num_bc,
                "cost": cost,
                "price": current_price
            }
        
        transaction = db.transaction()
        result = execute_buy(transaction)
        
        return {
            "success": True,
            "message": f"Bought {num_bc:.2f} BC for ${result['cost']:.2f}",
            "new_usd": result["new_usd"],
            "new_coins": result["new_coins"],
            "price": result["price"]
        }
    
    except ValueError as ve:
        return {"success": False, "error": str(ve)}
    except Exception as e:
        return {"success": False, "error": str(e)}


@https_fn.on_call()
def sell(req: https_fn.CallableRequest) -> Dict:
    """
    Sell BananaCoin
    
    Request data:
        user_id: str
        game_id: str
        num_bc: float
    """
    try:
        data = req.data
        user_id = data.get("user_id")
        game_id = data.get("game_id")
        num_bc = float(data.get("num_bc"))
        
        if num_bc <= 0:
            return {"success": False, "error": "Amount must be positive"}
        
        game_ref = db.collection("games").document(game_id)
        user_ref = game_ref.collection("users").document(user_id)
        
        # Use transaction for consistency
        @firestore.transactional
        def execute_sell(transaction):
            game_snap = game_ref.get(transaction=transaction)
            user_snap = user_ref.get(transaction=transaction)
            
            if not game_snap.exists or not user_snap.exists:
                raise ValueError("Game or user not found")
            
            game_data = game_snap.to_dict()
            user_data = user_snap.to_dict()
            
            if not game_data.get("is_started"):
                raise ValueError("Game not started")
            
            current_price = game_data["coin_value"]
            current_tick = game_data["current_tick"]
            
            if user_data["coins"] < num_bc:
                raise ValueError("Insufficient BC")
            
            revenue = num_bc * current_price
            
            # Update user wallet
            transaction.update(user_ref, {
                "usd": user_data["usd"] + revenue,
                "coins": user_data["coins"] - num_bc,
                "last_interaction_tick": current_tick
            })
            
            return {
                "new_usd": user_data["usd"] + revenue,
                "new_coins": user_data["coins"] - num_bc,
                "revenue": revenue,
                "price": current_price
            }
        
        transaction = db.transaction()
        result = execute_sell(transaction)
        
        return {
            "success": True,
            "message": f"Sold {num_bc:.2f} BC for ${result['revenue']:.2f}",
            "new_usd": result["new_usd"],
            "new_coins": result["new_coins"],
            "price": result["price"]
        }
    
    except ValueError as ve:
        return {"success": False, "error": str(ve)}
    except Exception as e:
        return {"success": False, "error": str(e)}


# ============================================================================
# BOT MANAGEMENT
# ============================================================================

@https_fn.on_call()
def buy_bot(req: https_fn.CallableRequest) -> Dict:
    """
    Purchase and activate a bot
    
    Request data:
        user_id: str
        game_id: str
        bot_type: str (random, momentum, mean_reversion, market_maker, hedger)
        parameters: dict (optional)
    """
    try:
        data = req.data
        user_id = data.get("user_id")
        game_id = data.get("game_id")
        bot_type = data.get("bot_type")
        parameters = data.get("parameters", {})
        
        valid_bot_types = ["random", "momentum", "mean_reversion", "market_maker", "hedger"]
        if bot_type not in valid_bot_types:
            return {"success": False, "error": "Invalid bot type"}
        
        game_ref = db.collection("games").document(game_id)
        user_ref = game_ref.collection("users").document(user_id)
        
        @firestore.transactional
        def execute_buy_bot(transaction):
            game_snap = game_ref.get(transaction=transaction)
            user_snap = user_ref.get(transaction=transaction)
            
            if not game_snap.exists or not user_snap.exists:
                raise ValueError("Game or user not found")
            
            game_data = game_snap.to_dict()
            user_data = user_snap.to_dict()
            
            if not game_data.get("is_started"):
                raise ValueError("Game not started")
            
            # Generate unique bot ID
            import uuid
            bot_id = str(uuid.uuid4())
            
            bot_data = {
                "bot_id": bot_id,
                "bot_type": bot_type,
                "creation_tick": game_data["current_tick"],
                "creation_price": game_data["coin_value"],
                "is_active": True,
                "parameters": parameters,
                "trades_executed": 0,
                "total_profit_loss": 0.0
            }
            
            # Add bot to user's bot list
            bots = user_data.get("bots", [])
            bots.append(bot_data)
            
            transaction.update(user_ref, {"bots": bots})
            
            return bot_id
        
        transaction = db.transaction()
        bot_id = execute_buy_bot(transaction)
        
        return {
            "success": True,
            "message": f"Bot '{bot_type}' activated",
            "bot_id": bot_id
        }
    
    except ValueError as ve:
        return {"success": False, "error": str(ve)}
    except Exception as e:
        return {"success": False, "error": str(e)}


@https_fn.on_call()
def toggle_bot(req: https_fn.CallableRequest) -> Dict:
    """
    Toggle a bot on/off
    
    Request data:
        user_id: str
        game_id: str
        bot_id: str
    """
    try:
        data = req.data
        user_id = data.get("user_id")
        game_id = data.get("game_id")
        bot_id = data.get("bot_id")
        
        game_ref = db.collection("games").document(game_id)
        user_ref = game_ref.collection("users").document(user_id)
        
        user_snap = user_ref.get()
        if not user_snap.exists:
            return {"success": False, "error": "User not found"}
        
        user_data = user_snap.to_dict()
        bots = user_data.get("bots", [])
        
        # Find and toggle the bot
        bot_found = False
        for bot in bots:
            if bot["bot_id"] == bot_id:
                bot["is_active"] = not bot["is_active"]
                bot_found = True
                new_state = "active" if bot["is_active"] else "inactive"
                break
        
        if not bot_found:
            return {"success": False, "error": "Bot not found"}
        
        user_ref.update({"bots": bots})
        
        return {
            "success": True,
            "message": f"Bot is now {new_state}",
            "is_active": bot["is_active"]
        }
    
    except Exception as e:
        return {"success": False, "error": str(e)}


# ============================================================================
# MARKET SIMULATION (Scheduled Function)
# ============================================================================

@scheduler_fn.on_schedule(schedule="every 1 seconds")
def simulate_market(event: scheduler_fn.ScheduledEvent) -> None:
    """
    Run market simulation every second
    Updates prices, applies decay, executes bots
    """
    try:
        # Get all active games
        games_ref = db.collection("games")
        active_games = games_ref.where("is_started", "==", True).where("is_finished", "==", False).stream()
        
        for game_snap in active_games:
            game_id = game_snap.id
            game_ref = db.collection("games").document(game_id)
            game_data = game_snap.to_dict()
            
            # Check if game should end
            start_time = game_data.get("start_time")
            duration = game_data["settings"]["duration"]
            
            if start_time:
                elapsed = (datetime.utcnow() - start_time).total_seconds()
                if elapsed >= duration:
                    game_ref.update({"is_finished": True})
                    continue
            
            # Increment tick
            current_tick = game_data.get("current_tick", 0) + 1
            current_price = game_data["coin_value"]
            price_history = game_data.get("price_history", [])
            
            # Calculate new volatility
            volatility = calculate_volatility(price_history)
            
            # Check for random events
            event = trigger_random_event(current_tick)
            event_impact = 0.0
            if event:
                event_impact = event["impact"]
                events = game_data.get("events", [])
                events.append(event)
                game_ref.update({"events": events})
            
            # Update price
            new_price = update_market_price(current_price, volatility)
            new_price *= (1 + event_impact)  # Apply event impact
            new_price = max(0.01, new_price)
            
            # Update price history
            price_history.append(new_price)
            
            # Update game state
            game_ref.update({
                "current_tick": current_tick,
                "coin_value": new_price,
                "price_history": price_history,
                "volatility": volatility
            })
            
            # Process all users: apply decay and run bots
            users_ref = game_ref.collection("users")
            users = users_ref.stream()
            
            for user_snap in users:
                user_id = user_snap.id
                user_ref = users_ref.document(user_id)
                user_data = user_snap.to_dict()
                
                # Apply decay to coins
                last_tick = user_data.get("last_interaction_tick", 0)
                current_coins = user_data["coins"]
                decayed_coins = calculate_decay(current_coins, last_tick, current_tick)
                
                # Run all active bots for this user
                bots = user_data.get("bots", [])
                for bot in bots:
                    if not bot.get("is_active", False):
                        continue
                    
                    # Simple bot execution (you'd integrate the full bot logic here)
                    bot_type = bot["bot_type"]
                    
                    # Execute bot trade (simplified - would use full bot classes)
                    # This is a placeholder - integrate with your bot system
                    pass
                
                # Update user data
                user_ref.update({
                    "coins": decayed_coins
                })
    
    except Exception as e:
        print(f"Error in simulate_market: {e}")


# ============================================================================
# QUERY FUNCTIONS
# ============================================================================

@https_fn.on_call()
def get_game_state(req: https_fn.CallableRequest) -> Dict:
    """
    Get current game state
    
    Request data:
        game_id: str
    """
    try:
        game_id = req.data.get("game_id")
        
        game_ref = db.collection("games").document(game_id)
        game = game_ref.get()
        
        if not game.exists:
            return {"success": False, "error": "Game not found"}
        
        game_data = game.to_dict()
        
        return {
            "success": True,
            "game_state": game_data
        }
    
    except Exception as e:
        return {"success": False, "error": str(e)}


@https_fn.on_call()
def get_leaderboard(req: https_fn.CallableRequest) -> Dict:
    """
    Get game leaderboard
    
    Request data:
        game_id: str
    """
    try:
        game_id = req.data.get("game_id")
        
        game_ref = db.collection("games").document(game_id)
        game = game_ref.get()
        
        if not game.exists:
            return {"success": False, "error": "Game not found"}
        
        game_data = game.to_dict()
        current_price = game_data["coin_value"]
        
        # Get all users and calculate portfolio values
        users_ref = game_ref.collection("users")
        users = users_ref.stream()
        
        leaderboard = []
        for user_snap in users:
            user_data = user_snap.to_dict()
            portfolio_value = user_data["usd"] + (user_data["coins"] * current_price)
            
            leaderboard.append({
                "user_id": user_data["user_id"],
                "user_name": user_data["user_name"],
                "portfolio_value": portfolio_value,
                "coins": user_data["coins"],
                "usd": user_data["usd"]
            })
        
        # Sort by portfolio value
        leaderboard.sort(key=lambda x: x["portfolio_value"], reverse=True)
        
        return {
            "success": True,
            "leaderboard": leaderboard
        }
    
    except Exception as e:
        return {"success": False, "error": str(e)}